{
    "version": "https://jsonfeed.org/version/1",
    "title": "Hexo",
    "subtitle": "",
    "icon": "http://example.com/assets/favicon.ico",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2024/09/20/Dijkstra%E7%AE%97%E6%B3%95%E6%AD%A3%E7%A1%AE%E6%80%A7%E7%9A%84%E8%AF%81%E6%98%8E/",
            "url": "http://example.com/2024/09/20/Dijkstra%E7%AE%97%E6%B3%95%E6%AD%A3%E7%A1%AE%E6%80%A7%E7%9A%84%E8%AF%81%E6%98%8E/",
            "title": "Dijkstra算法正确性的证明",
            "date_published": "2024-09-20T13:55:41.000Z",
            "content_html": "<h1 id=\"Dijkstra-算法正确性的证明\"><a href=\"#Dijkstra-算法正确性的证明\" class=\"headerlink\" title=\"Dijkstra 算法正确性的证明\"></a>Dijkstra 算法正确性的证明</h1><h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p>给定一个非负权边的图，规定起点为$u$，求从$u$出发到每一个节点的最短路径．（求解<strong>非负权</strong>图上<strong>单源</strong>最短路径）</p>\n<h3 id=\"流程简述\"><a href=\"#流程简述\" class=\"headerlink\" title=\"流程简述\"></a>流程简述</h3><p>将结点分成两个集合：已确定最短路长度的点集（记为$S$集合）的和未确定最短路长度的点集（记为$T$集合）．</p>\n<p>一开始所有的点都属于$T$集合，$\\mathrm{dis}(s) &#x3D; 0$，其他点的$\\mathrm{dis}$均为$+\\infty$．</p>\n<p>然后重复这些操作：</p>\n<ol>\n<li>从$T$集合中，选取一个最短路长度最小的结点，移到$S$集合中；</li>\n<li>对那些刚刚被加入$S$集合的结点的所有在$T$内的邻接点更新$\\mathrm{dis}$．</li>\n</ol>\n<p>直到$T$集合为空，算法结束．</p>\n<h3 id=\"正确性证明\"><a href=\"#正确性证明\" class=\"headerlink\" title=\"正确性证明\"></a>正确性证明</h3><p>显然，Dijkstra算法的正确性取决于命题「每当一个结点$v$加入$S$集合时，此时$\\mathrm{dis}(v)$对应的路径$r : u \\rightarrow v$的长必为全局最短路径长$D(v)$」的真伪．</p>\n<p>（反证法）<strong>假设存在另一条路径$r’ : u \\rightarrow v$为全局最短路径</strong>，即<br>$$<br>D(v) &lt; \\mathrm{dis}(v)<br>$$<br>有一个非常重要的点：**$r’$的结点中除了终点$v \\in T$，必然存在另一点$t \\in T$**．</p>\n<blockquote>\n<p>证明：（反证法）假设$r’$是<strong>只有终点$v$在$T$内的</strong>路径．</p>\n<p>根据操作2，<strong>此时$\\mathrm{dis}(v)$已经被$v$的所有在$S$内的前驱结点更新（不单只是$v$，$T$内所有的结点也被所有相应的前驱结点更新）</strong>，对应的路径$r$已经是所有<strong>只有终点$v$在$T$内的</strong>路径$u \\rightarrow v$中<strong>最短</strong>的一条路径，因此不存在另一条只有终点$v$在$T$内的路径$r’$，使得$r’$的路径长$|r’|$比$r$的路径长$|r|$短，与假设矛盾．</p>\n<p>故$r’$的结点中除了终点$v \\in T$，必然存在另一点$t \\in T$．</p>\n<p><img loading=\"lazy\" data-src=\"/2024/09/20/Dijkstra%E7%AE%97%E6%B3%95%E6%AD%A3%E7%A1%AE%E6%80%A7%E7%9A%84%E8%AF%81%E6%98%8E/114514.png\" alt=\"114514\"></p>\n</blockquote>\n<p>因此不妨设路径$r’$中<strong>第一个</strong>在$T$内的结点为$t$．</p>\n<p><img loading=\"lazy\" data-src=\"/2024/09/20/Dijkstra%E7%AE%97%E6%B3%95%E6%AD%A3%E7%A1%AE%E6%80%A7%E7%9A%84%E8%AF%81%E6%98%8E/1919810.png\" alt=\"1919810\"></p>\n<p>对于从$T$中<strong>通过Dijkstra算法选出来的</strong>结点$v$，有另一个非常重要的点：<strong>所有在$T$内的结点中，$\\mathrm{dis}(v)$最小</strong>．因此<br>$$<br>\\mathrm{dis}(t) \\ge \\mathrm{dis}(v)<br>$$<br><strong>在全局最短路径$r’$中</strong>，设局部路径<br>$$<br>s_1:u \\rightarrow t \\qquad s_2:t \\rightarrow v<br>$$<br>根据操作2，<strong>此时$\\mathrm{dis} (t)$已经被$t$的所有在$S$内的前驱结点更新</strong>，因此$\\mathrm{dis} (t)$对应的路径已经是<strong>只有终点$t$在$T$内的最短路径</strong>．因为$s_1 \\sube r’$，所以$s_1$必为$u \\rightarrow t$的<strong>全局</strong>最短路径，又因为$s_1$是只有终点$t$在$T$内的路径，故$s_1$也为<strong>只有终点$t$在$T$内的最短路径</strong>，因此有<br>$$<br>D(t) &#x3D; \\mathrm{dis} (t)<br>$$<br><strong>在非负权图中</strong>，有<br>$$<br>|s_2| \\ge 0<br>$$<br>根据假设（路径$r’: u \\rightarrow t \\rightarrow v$为全局最短路径），有<br>$$<br>D(v) &#x3D; D(t) + |s_2| &#x3D; \\mathrm{dis}(t) + |s_2| \\ge \\mathrm{dis}(t) \\ge \\mathrm{dis}(v) &gt; D(v)<br>$$<br>这显然不成立，原命题得证．</p>\n",
            "tags": [
                "算法",
                "图论",
                "最短路"
            ]
        },
        {
            "id": "http://example.com/2024/09/20/hello-world/",
            "url": "http://example.com/2024/09/20/hello-world/",
            "title": "Hello World",
            "date_published": "2024-09-20T13:25:30.654Z",
            "content_html": "<p>$$<br>\\int_{a}^{b} x^2 dx<br>$$</p>\n<p>$$<br>\\sum_{n&#x3D;1}^{\\infty} 2^{-n} &#x3D; 1<br>$$</p>\n<p>$$<br>\\lim_{x\\to\\infty} f(x)<br>$$</p>\n<p>$$<br>A\\boldsymbol{x}&#x3D;\\begin{bmatrix}a_{11}&amp;a_{12}&amp;\\cdots&amp;a_{1n}\\a_{21}&amp;a_{22}&amp;\\cdots&amp;a_{2n}\\\\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\a_{m1}&amp;a_{m2}&amp;\\cdots&amp;a_{mn}\\end{bmatrix}\\begin{bmatrix}x_1\\x_2\\\\vdots\\\\vdots\\x_n\\end{bmatrix}&#x3D;\\begin{bmatrix}a_{11}x_1+a_{12}x_2+\\cdots+a_{1n}x_n\\a_{21}x_1+a_{22}x_2+\\cdots+a_{2n}x_n\\\\vdots\\a_{m1}x_1+a_{m2}x_2+\\cdots+a_{mn}x_n\\end{bmatrix}<br>$$</p>\n",
            "tags": []
        }
    ]
}